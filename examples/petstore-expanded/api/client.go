// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/discord-gophers/goapi-gen version (devel) DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/carlmjohnson/requests"
)

type Client struct {
	BaseURL             string
	Client              *http.Client
	ResponseInterceptor func(*http.Response) error
	RequestOptions      func(*requests.Builder) *requests.Builder
}

// FindPets Returns all pets
func (c *Client) FindPets(ctx context.Context, p FindPetsParams) (*[]Pet, *Error, error) {
	req := &requests.Builder{}
	req = req.Client(c.Client)
	req = req.Method(http.MethodGet)
	req = req.BaseURL(c.BaseURL)
	req = req.Path("/pets")

	if p.Tags != nil {
		req = req.Param("tags", strings.Join(p.Tags, ","))
	}
	if p.Limit != nil {
		req = req.Param("limit", fmt.Sprint(*p.Limit))
	}

	// define out handlers
	read := false // flag such that empty responses are kept nil
	var _200 *[]Pet
	handle200 := func(resp *http.Response) error {
		if resp.StatusCode == 200 {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_200 = new([]Pet)
		err := json.NewDecoder(resp.Body).Decode(_200)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_200 = nil
			return nil
		}
		return err
	}

	var _default *Error
	handledefault := func(resp *http.Response) error {
		if resp.StatusCode != 0 {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_default = new(Error)
		err := json.NewDecoder(resp.Body).Decode(_default)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_default = nil
			return nil
		}
		return err
	}

	handlers := []func(*http.Response) error{}
	if c.ResponseInterceptor != nil {
		handlers = append(handlers, c.ResponseInterceptor)
	}

	handlers = append(handlers, handle200)
	handlers = append(handlers, handledefault)
	req = req.Handle(requests.ChainHandlers(handlers...))

	if c.RequestOptions != nil {
		req = c.RequestOptions(req)
	}
	err := req.Fetch(ctx)
	if err != nil {
		return nil, nil, err
	}

	return _200, _default, nil
}

// AddPet Creates a new pet
func (c *Client) AddPet(ctx context.Context, body NewPet) (*Pet, *Error, error) {
	req := &requests.Builder{}
	req = req.Client(c.Client)
	req = req.Method(http.MethodPost)
	req = req.BaseURL(c.BaseURL)
	req = req.Path("/pets")

	req = req.BodyJSON(body)
	req = req.ContentType("application/json")

	// define out handlers
	read := false // flag such that empty responses are kept nil
	var _201 *Pet
	handle201 := func(resp *http.Response) error {
		if resp.StatusCode == 201 {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_201 = new(Pet)
		err := json.NewDecoder(resp.Body).Decode(_201)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_201 = nil
			return nil
		}
		return err
	}

	var _default *Error
	handledefault := func(resp *http.Response) error {
		if resp.StatusCode != 0 {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_default = new(Error)
		err := json.NewDecoder(resp.Body).Decode(_default)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_default = nil
			return nil
		}
		return err
	}

	handlers := []func(*http.Response) error{}
	if c.ResponseInterceptor != nil {
		handlers = append(handlers, c.ResponseInterceptor)
	}

	handlers = append(handlers, handle201)
	handlers = append(handlers, handledefault)
	req = req.Handle(requests.ChainHandlers(handlers...))

	if c.RequestOptions != nil {
		req = c.RequestOptions(req)
	}
	err := req.Fetch(ctx)
	if err != nil {
		return nil, nil, err
	}

	return _201, _default, nil
}

// DeletePet Deletes a pet by ID
func (c *Client) DeletePet(ctx context.Context, id int64) (*Error, error) {
	req := &requests.Builder{}
	req = req.Client(c.Client)
	req = req.Method(http.MethodDelete)
	req = req.BaseURL(c.BaseURL)
	req = req.Path(strings.NewReplacer("{id}", fmt.Sprint(id)).Replace("/pets/{id}"))

	// define out handlers
	read := false // flag such that empty responses are kept nil
	var _default *Error
	handledefault := func(resp *http.Response) error {
		if resp.StatusCode != 0 {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_default = new(Error)
		err := json.NewDecoder(resp.Body).Decode(_default)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_default = nil
			return nil
		}
		return err
	}

	handlers := []func(*http.Response) error{}
	if c.ResponseInterceptor != nil {
		handlers = append(handlers, c.ResponseInterceptor)
	}

	handlers = append(handlers, handledefault)
	req = req.Handle(requests.ChainHandlers(handlers...))

	if c.RequestOptions != nil {
		req = c.RequestOptions(req)
	}
	err := req.Fetch(ctx)
	if err != nil {
		return nil, err
	}

	return _default, nil
}

// FindPetByID Returns a pet by ID
func (c *Client) FindPetByID(ctx context.Context, id int64) (*Pet, *Error, error) {
	req := &requests.Builder{}
	req = req.Client(c.Client)
	req = req.Method(http.MethodGet)
	req = req.BaseURL(c.BaseURL)
	req = req.Path(strings.NewReplacer("{id}", fmt.Sprint(id)).Replace("/pets/{id}"))

	// define out handlers
	read := false // flag such that empty responses are kept nil
	var _200 *Pet
	handle200 := func(resp *http.Response) error {
		if resp.StatusCode == 200 {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_200 = new(Pet)
		err := json.NewDecoder(resp.Body).Decode(_200)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_200 = nil
			return nil
		}
		return err
	}

	var _default *Error
	handledefault := func(resp *http.Response) error {
		if resp.StatusCode != 0 {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_default = new(Error)
		err := json.NewDecoder(resp.Body).Decode(_default)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_default = nil
			return nil
		}
		return err
	}

	handlers := []func(*http.Response) error{}
	if c.ResponseInterceptor != nil {
		handlers = append(handlers, c.ResponseInterceptor)
	}

	handlers = append(handlers, handle200)
	handlers = append(handlers, handledefault)
	req = req.Handle(requests.ChainHandlers(handlers...))

	if c.RequestOptions != nil {
		req = c.RequestOptions(req)
	}
	err := req.Fetch(ctx)
	if err != nil {
		return nil, nil, err
	}

	return _200, _default, nil
}

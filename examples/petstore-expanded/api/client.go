// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/discord-gophers/goapi-gen version (devel) DO NOT EDIT.
package api

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/carlmjohnson/requests"
)

type Client struct {
	BaseURL string
	Client  *http.Client
}

// FindPets Returns all pets
func (c *Client) FindPets(ctx context.Context, p FindPetsParams) (*[]Pet, *Error, error) {

	req := &requests.Builder{}
	req = req.Client(c.Client)
	req = req.Method("GET")
	req = req.BaseURL(c.BaseURL)
	req = req.Path("/pets")

	if p.Tags != nil {
		req = req.Param("tags", strings.Join(p.Tags, ","))
	}
	if p.Limit != nil {
		req = req.Param("limit", fmt.Sprint(p.Limit))
	}

	// define out handlers
	read := false // flag such that empty responses are kept nil
	is200 := func(resp *http.Response) bool {
		return resp.StatusCode == 200
	}
	var _200 *[]Pet
	handle200 := func(resp *http.Response) error {
		if !is200(resp) {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_200 = new([]Pet)
		err := json.NewDecoder(resp.Body).Decode(_200)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_200 = nil
			return nil
		}
		return err
	}

	isdefault := func(resp *http.Response) bool {
		return resp.StatusCode != 0
	}
	var _default *Error
	handledefault := func(resp *http.Response) error {
		if !isdefault(resp) {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_default = new(Error)
		err := json.NewDecoder(resp.Body).Decode(_default)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_default = nil
			return nil
		}
		return err
	}

	req = req.Handle(requests.ChainHandlers(handle200, handledefault))
	err := req.Fetch(ctx)
	if err != nil {
		return nil, nil, err
	}

	return _200, _default, nil
}

// AddPet Creates a new pet
func (c *Client) AddPet(ctx context.Context, body NewPet) (*Pet, *Error, error) {

	req := &requests.Builder{}
	req = req.Client(c.Client)
	req = req.Method("POST")
	req = req.BaseURL(c.BaseURL)
	req = req.Path("/pets")

	req = req.BodyJSON(body)
	req = req.ContentType("application/json")

	// define out handlers
	read := false // flag such that empty responses are kept nil
	is201 := func(resp *http.Response) bool {
		return resp.StatusCode == 201
	}
	var _201 *Pet
	handle201 := func(resp *http.Response) error {
		if !is201(resp) {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_201 = new(Pet)
		err := json.NewDecoder(resp.Body).Decode(_201)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_201 = nil
			return nil
		}
		return err
	}

	isdefault := func(resp *http.Response) bool {
		return resp.StatusCode != 0
	}
	var _default *Error
	handledefault := func(resp *http.Response) error {
		if !isdefault(resp) {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_default = new(Error)
		err := json.NewDecoder(resp.Body).Decode(_default)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_default = nil
			return nil
		}
		return err
	}

	req = req.Handle(requests.ChainHandlers(handle201, handledefault))
	err := req.Fetch(ctx)
	if err != nil {
		return nil, nil, err
	}

	return _201, _default, nil
}

// DeletePet Deletes a pet by ID
func (c *Client) DeletePet(ctx context.Context, id int64) (*Error, error) {

	req := &requests.Builder{}
	req = req.Client(c.Client)
	req = req.Method("DELETE")
	req = req.BaseURL(c.BaseURL)
	req = req.Path(strings.NewReplacer("{id}", fmt.Sprint(id)).Replace("/pets/{id}"))

	// define out handlers
	read := false // flag such that empty responses are kept nil
	isdefault := func(resp *http.Response) bool {
		return resp.StatusCode != 0
	}
	var _default *Error
	handledefault := func(resp *http.Response) error {
		if !isdefault(resp) {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_default = new(Error)
		err := json.NewDecoder(resp.Body).Decode(_default)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_default = nil
			return nil
		}
		return err
	}

	req = req.Handle(requests.ChainHandlers(handledefault))
	err := req.Fetch(ctx)
	if err != nil {
		return nil, err
	}

	return _default, nil
}

// FindPetByID Returns a pet by ID
func (c *Client) FindPetByID(ctx context.Context, id int64) (*Pet, *Error, error) {

	req := &requests.Builder{}
	req = req.Client(c.Client)
	req = req.Method("GET")
	req = req.BaseURL(c.BaseURL)
	req = req.Path(strings.NewReplacer("{id}", fmt.Sprint(id)).Replace("/pets/{id}"))

	// define out handlers
	read := false // flag such that empty responses are kept nil
	is200 := func(resp *http.Response) bool {
		return resp.StatusCode == 200
	}
	var _200 *Pet
	handle200 := func(resp *http.Response) error {
		if !is200(resp) {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_200 = new(Pet)
		err := json.NewDecoder(resp.Body).Decode(_200)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_200 = nil
			return nil
		}
		return err
	}

	isdefault := func(resp *http.Response) bool {
		return resp.StatusCode != 0
	}
	var _default *Error
	handledefault := func(resp *http.Response) error {
		if !isdefault(resp) {
			return nil
		}

		if read {
			return nil
		}
		read = true

		_default = new(Error)
		err := json.NewDecoder(resp.Body).Decode(_default)
		switch err {
		case nil:
			return nil
		case io.EOF:
			_default = nil
			return nil
		}
		return err
	}

	req = req.Handle(requests.ChainHandlers(handle200, handledefault))
	err := req.Fetch(ctx)
	if err != nil {
		return nil, nil, err
	}

	return _200, _default, nil
}

// Package parameters provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/discord-gophers/goapi-gen version (devel) DO NOT EDIT.
package parameters

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/discord-gophers/goapi-gen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/render"
)

// ComplexObject defines model for ComplexObject.
type ComplexObject struct {
	ID      int    `json:"Id"`
	IsAdmin bool   `json:"IsAdmin"`
	Object  Object `json:"Object"`
}

// Object defines model for Object.
type Object struct {
	FirstName string `json:"firstName"`
	Role      string `json:"role"`
}

// GetCookieParams defines parameters for GetCookie.
type GetCookieParams struct {
	// primitive
	P *int32 `json:"p,omitempty"`

	// primitive
	Ep *int32 `json:"ep,omitempty"`

	// exploded array
	Ea *[]int32 `json:"ea,omitempty"`

	// array
	A *[]int32 `json:"a,omitempty"`

	// exploded object
	Eo *Object `json:"eo,omitempty"`

	// object
	O *Object `json:"o,omitempty"`

	// complex object
	Co *ComplexObject `json:"co,omitempty"`

	// name starting with number
	N1s *string `json:"1s,omitempty"`
}

// GetHeaderParams defines parameters for GetHeader.
type GetHeaderParams struct {
	// primitive
	XPrimitive *int32 `json:"X-Primitive,omitempty"`

	// primitive
	XPrimitiveExploded *int32 `json:"X-Primitive-Exploded,omitempty"`

	// exploded array
	XArrayExploded *[]int32 `json:"X-Array-Exploded,omitempty"`

	// array
	XArray *[]int32 `json:"X-Array,omitempty"`

	// exploded object
	XObjectExploded *Object `json:"X-Object-Exploded,omitempty"`

	// object
	XObject *Object `json:"X-Object,omitempty"`

	// complex object
	XComplexObject *ComplexObject `json:"X-Complex-Object,omitempty"`

	// name starting with number
	N1StartingWithNumber *string `json:"1-Starting-With-Number,omitempty"`
}

// GetDeepObjectParams defines parameters for GetDeepObject.
type GetDeepObjectParams struct {
	// deep object
	DeepObj ComplexObject `json:"deepObj"`
}

// GetQueryFormParams defines parameters for GetQueryForm.
type GetQueryFormParams struct {
	// exploded array
	Ea *[]int32 `json:"ea,omitempty"`

	// array
	A *[]int32 `json:"a,omitempty"`

	// exploded object
	Eo *Object `json:"eo,omitempty"`

	// object
	O *Object `json:"o,omitempty"`

	// exploded primitive
	Ep *int32 `json:"ep,omitempty"`

	// primitive
	P *int32 `json:"p,omitempty"`

	// primitive string
	Ps *string `json:"ps,omitempty"`

	// complex object
	Co *ComplexObject `json:"co,omitempty"`

	// name starting with number
	N1s *string `json:"1s,omitempty"`
}

// Response is a common response struct for all the API calls.
// A Response object may be instantiated via functions for specific operation responses.
type Response struct {
	body        interface{}
	statusCode  int
	contentType string
}

// Render implements the render.Renderer interface. It sets the Content-Type header
// and status code based on the response definition.
func (resp *Response) Render(w http.ResponseWriter, r *http.Request) error {
	w.Header().Set("Content-Type", resp.contentType)
	render.Status(r, resp.statusCode)
	return nil
}

// Status is a builder method to override the default status code for a response.
func (resp *Response) Status(statusCode int) *Response {
	resp.statusCode = statusCode
	return resp
}

// ContentType is a builder method to override the default content type for a response.
func (resp *Response) ContentType(contentType string) *Response {
	resp.contentType = contentType
	return resp
}

// MarshalJSON implements the json.Marshaler interface.
// This is used to only marshal the body of the response.
func (resp *Response) MarshalJSON() ([]byte, error) {
	return json.Marshal(resp.body)
}

// MarshalXML implements the xml.Marshaler interface.
// This is used to only marshal the body of the response.
func (resp *Response) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	return e.Encode(resp.body)
}

// ClientInterface is implemented by Client
type ClientInterface interface {
	// GetContentObject makes the request to the API endpoint.
	GetContentObject(ctx context.Context, params GetContentObjectClientParams, opts ...func(*http.Request) error) error
	// GetCookie makes the request to the API endpoint.
	GetCookie(ctx context.Context, params GetCookieClientParams, opts ...func(*http.Request) error) error
	// GetHeader makes the request to the API endpoint.
	GetHeader(ctx context.Context, params GetHeaderClientParams, opts ...func(*http.Request) error) error
	// GetLabelExplodeArray makes the request to the API endpoint.
	GetLabelExplodeArray(ctx context.Context, params GetLabelExplodeArrayClientParams, opts ...func(*http.Request) error) error
	// GetLabelExplodeObject makes the request to the API endpoint.
	GetLabelExplodeObject(ctx context.Context, params GetLabelExplodeObjectClientParams, opts ...func(*http.Request) error) error
	// GetLabelNoExplodeArray makes the request to the API endpoint.
	GetLabelNoExplodeArray(ctx context.Context, params GetLabelNoExplodeArrayClientParams, opts ...func(*http.Request) error) error
	// GetLabelNoExplodeObject makes the request to the API endpoint.
	GetLabelNoExplodeObject(ctx context.Context, params GetLabelNoExplodeObjectClientParams, opts ...func(*http.Request) error) error
	// GetMatrixExplodeArray makes the request to the API endpoint.
	GetMatrixExplodeArray(ctx context.Context, params GetMatrixExplodeArrayClientParams, opts ...func(*http.Request) error) error
	// GetMatrixExplodeObject makes the request to the API endpoint.
	GetMatrixExplodeObject(ctx context.Context, params GetMatrixExplodeObjectClientParams, opts ...func(*http.Request) error) error
	// GetMatrixNoExplodeArray makes the request to the API endpoint.
	GetMatrixNoExplodeArray(ctx context.Context, params GetMatrixNoExplodeArrayClientParams, opts ...func(*http.Request) error) error
	// GetMatrixNoExplodeObject makes the request to the API endpoint.
	GetMatrixNoExplodeObject(ctx context.Context, params GetMatrixNoExplodeObjectClientParams, opts ...func(*http.Request) error) error
	// GetPassThrough makes the request to the API endpoint.
	GetPassThrough(ctx context.Context, params GetPassThroughClientParams, opts ...func(*http.Request) error) error
	// GetDeepObject makes the request to the API endpoint.
	GetDeepObject(ctx context.Context, params GetDeepObjectClientParams, opts ...func(*http.Request) error) error
	// GetQueryForm makes the request to the API endpoint.
	GetQueryForm(ctx context.Context, params GetQueryFormClientParams, opts ...func(*http.Request) error) error
	// GetSimpleExplodeArray makes the request to the API endpoint.
	GetSimpleExplodeArray(ctx context.Context, params GetSimpleExplodeArrayClientParams, opts ...func(*http.Request) error) error
	// GetSimpleExplodeObject makes the request to the API endpoint.
	GetSimpleExplodeObject(ctx context.Context, params GetSimpleExplodeObjectClientParams, opts ...func(*http.Request) error) error
	// GetSimpleNoExplodeArray makes the request to the API endpoint.
	GetSimpleNoExplodeArray(ctx context.Context, params GetSimpleNoExplodeArrayClientParams, opts ...func(*http.Request) error) error
	// GetSimpleNoExplodeObject makes the request to the API endpoint.
	GetSimpleNoExplodeObject(ctx context.Context, params GetSimpleNoExplodeObjectClientParams, opts ...func(*http.Request) error) error
	// GetSimplePrimitive makes the request to the API endpoint.
	GetSimplePrimitive(ctx context.Context, params GetSimplePrimitiveClientParams, opts ...func(*http.Request) error) error
	// GetStartingWithNumber makes the request to the API endpoint.
	GetStartingWithNumber(ctx context.Context, params GetStartingWithNumberClientParams, opts ...func(*http.Request) error) error
}

// Doer performs HTTP requests.
// The standard http.Client implements this interface.
type Doer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://example.com for example. This can contain a path relative
	// to the server, such as https://example.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	BaseURL string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	client Doer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	reqEditors []func(req *http.Request) error
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		BaseURL: server,
		client:  &http.Client{},
	}

	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}

	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.BaseURL, "/") {
		client.BaseURL += "/"
	}

	return &client, nil
}

// WithDoer allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithDoer(doer Doer) ClientOption {
	return func(c *Client) error {
		c.client = doer
		return nil
	}
}

// WithEditors allows setting up request editors, which are used to modify
func WithEditors(fns ...func(req *http.Request) error) ClientOption {
	return func(c *Client) error {
		c.reqEditors = append(c.reqEditors, fns...)
		return nil
	}
}

type ReqResponse struct {
	*http.Response
}

// Decode is a package-level variable set to our default Decoder. We do this
// because it allows you to set Decode to another function with the
// same function signature, while also utilizing the Decoder() function
// itself. Effectively, allowing you to easily add your own logic to the package
// defaults. For example, maybe you want to impose a limit on the number of
// bytes allowed to be read from the request body.
var ReqDecoder = defaultDecoder

// defaultDecoder detects the correct decoder for use on an HTTP request and
// marshals into a given interface.
func defaultDecoder(resp *http.Response, v interface{}) error {
	var err error

	switch render.GetContentType(resp.Header.Get("Content-Type")) {
	case render.ContentTypeJSON:
		err = render.DecodeJSON(resp.Body, v)
	case render.ContentTypeXML:
		err = render.DecodeXML(resp.Body, v)
	default:
		err = errors.New("defaultDecoder: unable to automatically decode the request content type")
	}

	return err
}

// We generate a new type for each client function such that we have all required in this parameter.
// Having a parameter like this is good because we don't break the function signature if things change inside.
// This is also cleaner than having all parameters as function parameters.
// The only issue is that it easily gets quite big

type GetContentObjectClientParams struct {
	Param string `json:"param"`
}

type GetCookieClientParams struct {
	// primitive
	P **http.Cookie `json:"p"`
	// primitive
	Ep **http.Cookie `json:"ep"`
	// exploded array
	Ea *http.Cookie `json:"ea,omitempty"`
	// array
	A *http.Cookie `json:"a,omitempty"`
	// exploded object
	Eo **http.Cookie `json:"eo"`
	// object
	O **http.Cookie `json:"o"`
	// complex object
	Co **http.Cookie `json:"co"`
	// name starting with number
	N1s **http.Cookie `json:"1s"`
}

type GetHeaderClientParams struct {
	// primitive
	XPrimitive *string `json:"X-Primitive"`
	// primitive
	XPrimitiveExploded *string `json:"X-Primitive-Exploded"`
	// exploded array
	XArrayExploded string `json:"X-Array-Exploded,omitempty"`
	// array
	XArray string `json:"X-Array,omitempty"`
	// exploded object
	XObjectExploded *string `json:"X-Object-Exploded"`
	// object
	XObject *string `json:"X-Object"`
	// complex object
	XComplexObject *string `json:"X-Complex-Object"`
	// name starting with number
	N1startingWithNumber *string `json:"1-Starting-With-Number"`
}

type GetLabelExplodeArrayClientParams struct {
	Param string `json:"param"`
}

type GetLabelExplodeObjectClientParams struct {
	Param string `json:"param"`
}

type GetLabelNoExplodeArrayClientParams struct {
	Param string `json:"param"`
}

type GetLabelNoExplodeObjectClientParams struct {
	Param string `json:"param"`
}

type GetMatrixExplodeArrayClientParams struct {
	ID string `json:"id"`
}

type GetMatrixExplodeObjectClientParams struct {
	ID string `json:"id"`
}

type GetMatrixNoExplodeArrayClientParams struct {
	ID string `json:"id"`
}

type GetMatrixNoExplodeObjectClientParams struct {
	ID string `json:"id"`
}

type GetPassThroughClientParams struct {
	Param string `json:"param"`
}

type GetDeepObjectClientParams struct {
	// deep object
	DeepObj string `json:"deepObj"`
}

type GetQueryFormClientParams struct {
	// exploded array
	Ea string `json:"ea,omitempty"`
	// array
	A string `json:"a,omitempty"`
	// exploded object
	Eo *string `json:"eo"`
	// object
	O *string `json:"o"`
	// exploded primitive
	Ep *string `json:"ep"`
	// primitive
	P *string `json:"p"`
	// primitive string
	Ps *string `json:"ps"`
	// complex object
	Co *string `json:"co"`
	// name starting with number
	N1s *string `json:"1s"`
}

type GetSimpleExplodeArrayClientParams struct {
	Param string `json:"param"`
}

type GetSimpleExplodeObjectClientParams struct {
	Param string `json:"param"`
}

type GetSimpleNoExplodeArrayClientParams struct {
	Param string `json:"param"`
}

type GetSimpleNoExplodeObjectClientParams struct {
	Param string `json:"param"`
}

type GetSimplePrimitiveClientParams struct {
	Param string `json:"param"`
}

type GetStartingWithNumberClientParams struct {
	N1param string `json:"1param"`
}

func buildURL(baseURL string, pathParams map[string]string, queryParams map[string]string) string {
	u, err := url.Parse(baseURL)
	if err != nil {
		panic(err)
	}

	// add path parameters
	for name, value := range pathParams {
		u.Path = strings.Replace(u.Path, "{"+name+"}", value, 1)
	}

	// add query parameters
	q := u.Query()
	for key, value := range queryParams {
		q.Set(key, value)
	}
	u.RawQuery = q.Encode()

	return u.String()
}

// GetContentObject makes the request to the API endpoint.
func (c *Client) GetContentObject(ctx context.Context, params GetContentObjectClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetCookie makes the request to the API endpoint.
func (c *Client) GetCookie(ctx context.Context, params GetCookieClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",
		c.BaseURL,
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	} // Set the cookies

	req.AddCookie(*params.P)
	req.AddCookie(*params.Ep)
	req.AddCookie(params.Ea)
	req.AddCookie(params.A)
	req.AddCookie(*params.Eo)
	req.AddCookie(*params.O)
	req.AddCookie(*params.Co)
	req.AddCookie(*params.N1s)

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetHeader makes the request to the API endpoint.
func (c *Client) GetHeader(ctx context.Context, params GetHeaderClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",
		c.BaseURL,
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	} // Set the headers

	req.Header.Set("X-Primitive", *params.XPrimitive)
	req.Header.Set("X-Primitive-Exploded", *params.XPrimitiveExploded)
	req.Header.Set("X-Array-Exploded", params.XArrayExploded)
	req.Header.Set("X-Array", params.XArray)
	req.Header.Set("X-Object-Exploded", *params.XObjectExploded)
	req.Header.Set("X-Object", *params.XObject)
	req.Header.Set("X-Complex-Object", *params.XComplexObject)
	req.Header.Set("1-Starting-With-Number", *params.N1startingWithNumber)

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetLabelExplodeArray makes the request to the API endpoint.
func (c *Client) GetLabelExplodeArray(ctx context.Context, params GetLabelExplodeArrayClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetLabelExplodeObject makes the request to the API endpoint.
func (c *Client) GetLabelExplodeObject(ctx context.Context, params GetLabelExplodeObjectClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetLabelNoExplodeArray makes the request to the API endpoint.
func (c *Client) GetLabelNoExplodeArray(ctx context.Context, params GetLabelNoExplodeArrayClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetLabelNoExplodeObject makes the request to the API endpoint.
func (c *Client) GetLabelNoExplodeObject(ctx context.Context, params GetLabelNoExplodeObjectClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetMatrixExplodeArray makes the request to the API endpoint.
func (c *Client) GetMatrixExplodeArray(ctx context.Context, params GetMatrixExplodeArrayClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"id": params.ID,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetMatrixExplodeObject makes the request to the API endpoint.
func (c *Client) GetMatrixExplodeObject(ctx context.Context, params GetMatrixExplodeObjectClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"id": params.ID,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetMatrixNoExplodeArray makes the request to the API endpoint.
func (c *Client) GetMatrixNoExplodeArray(ctx context.Context, params GetMatrixNoExplodeArrayClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"id": params.ID,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetMatrixNoExplodeObject makes the request to the API endpoint.
func (c *Client) GetMatrixNoExplodeObject(ctx context.Context, params GetMatrixNoExplodeObjectClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"id": params.ID,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetPassThrough makes the request to the API endpoint.
func (c *Client) GetPassThrough(ctx context.Context, params GetPassThroughClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetDeepObject makes the request to the API endpoint.
func (c *Client) GetDeepObject(ctx context.Context, params GetDeepObjectClientParams, opts ...func(*http.Request) error) error {

	queryParams := make(map[string]string)
	if params.DeepObj != nil {
		queryParams["deepObj"] = *params.DeepObj
	}

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			nil,
			queryParams,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetQueryForm makes the request to the API endpoint.
func (c *Client) GetQueryForm(ctx context.Context, params GetQueryFormClientParams, opts ...func(*http.Request) error) error {

	queryParams := make(map[string]string)
	queryParams["ea"] = params.Ea
	queryParams["a"] = params.A
	if params.Eo != nil {
		queryParams["eo"] = *params.Eo
	}
	if params.O != nil {
		queryParams["o"] = *params.O
	}
	if params.Ep != nil {
		queryParams["ep"] = *params.Ep
	}
	if params.P != nil {
		queryParams["p"] = *params.P
	}
	if params.Ps != nil {
		queryParams["ps"] = *params.Ps
	}
	if params.Co != nil {
		queryParams["co"] = *params.Co
	}
	if params.N1s != nil {
		queryParams["1s"] = *params.N1s
	}

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			nil,
			queryParams,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetSimpleExplodeArray makes the request to the API endpoint.
func (c *Client) GetSimpleExplodeArray(ctx context.Context, params GetSimpleExplodeArrayClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetSimpleExplodeObject makes the request to the API endpoint.
func (c *Client) GetSimpleExplodeObject(ctx context.Context, params GetSimpleExplodeObjectClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetSimpleNoExplodeArray makes the request to the API endpoint.
func (c *Client) GetSimpleNoExplodeArray(ctx context.Context, params GetSimpleNoExplodeArrayClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetSimpleNoExplodeObject makes the request to the API endpoint.
func (c *Client) GetSimpleNoExplodeObject(ctx context.Context, params GetSimpleNoExplodeObjectClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetSimplePrimitive makes the request to the API endpoint.
func (c *Client) GetSimplePrimitive(ctx context.Context, params GetSimplePrimitiveClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"param": params.Param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// GetStartingWithNumber makes the request to the API endpoint.
func (c *Client) GetStartingWithNumber(ctx context.Context, params GetStartingWithNumberClientParams, opts ...func(*http.Request) error) error {

	// Create the request
	req, err := http.NewRequestWithContext(
		ctx,
		"GET",

		buildURL(
			c.BaseURL,
			map[string]string{
				"1param": params.N1param,
			},
			nil,
		),
		nil,
	)
	if err != nil {
		return fmt.Errorf("failed to build request: %w", err)
	}

	// Apply any request editors
	for _, fn := range c.reqEditors {
		if err := fn(req); err != nil {
			return fmt.Errorf("failed to apply request editor: %w", err)
		}
	}

	// Do the request
	_, errDo := c.client.Do(req)
	if errDo != nil {
		return fmt.Errorf("failed to send request: %w", errDo)
	}

	return nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /contentObject/{param})
	GetContentObject(w http.ResponseWriter, r *http.Request, param ComplexObject)

	// (GET /cookie)
	GetCookie(w http.ResponseWriter, r *http.Request, params GetCookieParams)

	// (GET /header)
	GetHeader(w http.ResponseWriter, r *http.Request, params GetHeaderParams)

	// (GET /labelExplodeArray/{.param*})
	GetLabelExplodeArray(w http.ResponseWriter, r *http.Request, param []int32)

	// (GET /labelExplodeObject/{.param*})
	GetLabelExplodeObject(w http.ResponseWriter, r *http.Request, param Object)

	// (GET /labelNoExplodeArray/{.param})
	GetLabelNoExplodeArray(w http.ResponseWriter, r *http.Request, param []int32)

	// (GET /labelNoExplodeObject/{.param})
	GetLabelNoExplodeObject(w http.ResponseWriter, r *http.Request, param Object)

	// (GET /matrixExplodeArray/{.id*})
	GetMatrixExplodeArray(w http.ResponseWriter, r *http.Request, id []int32)

	// (GET /matrixExplodeObject/{.id*})
	GetMatrixExplodeObject(w http.ResponseWriter, r *http.Request, id Object)

	// (GET /matrixNoExplodeArray/{.id})
	GetMatrixNoExplodeArray(w http.ResponseWriter, r *http.Request, id []int32)

	// (GET /matrixNoExplodeObject/{.id})
	GetMatrixNoExplodeObject(w http.ResponseWriter, r *http.Request, id Object)

	// (GET /passThrough/{param})
	GetPassThrough(w http.ResponseWriter, r *http.Request, param string)

	// (GET /queryDeepObject)
	GetDeepObject(w http.ResponseWriter, r *http.Request, params GetDeepObjectParams)

	// (GET /queryForm)
	GetQueryForm(w http.ResponseWriter, r *http.Request, params GetQueryFormParams)

	// (GET /simpleExplodeArray/{param*})
	GetSimpleExplodeArray(w http.ResponseWriter, r *http.Request, param []int32)

	// (GET /simpleExplodeObject/{param*})
	GetSimpleExplodeObject(w http.ResponseWriter, r *http.Request, param Object)

	// (GET /simpleNoExplodeArray/{param})
	GetSimpleNoExplodeArray(w http.ResponseWriter, r *http.Request, param []int32)

	// (GET /simpleNoExplodeObject/{param})
	GetSimpleNoExplodeObject(w http.ResponseWriter, r *http.Request, param Object)

	// (GET /simplePrimitive/{param})
	GetSimplePrimitive(w http.ResponseWriter, r *http.Request, param int32)

	// (GET /startingWithNumber/{1param})
	GetStartingWithNumber(w http.ResponseWriter, r *http.Request, n1param string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler          ServerInterface
	Middlewares      map[string]func(http.Handler) http.Handler
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// GetContentObject operation middleware
func (siw *ServerInterfaceWrapper) GetContentObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param ComplexObject

	if err := json.Unmarshal([]byte(chi.URLParam(r, "param")), &param); err != nil {
		err = fmt.Errorf("error unmarshaling parameter 'param' as JSON: %w", err)
		siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetContentObject(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetCookie operation middleware
func (siw *ServerInterfaceWrapper) GetCookie(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCookieParams

	if cookie, err := r.Cookie("p"); err == nil {
		var value int32
		if err := runtime.BindStyledParameter("simple", false, "p", cookie.Value, &value); err != nil {
			err = fmt.Errorf("invalid format for parameter p: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}
		params.P = &value

	}

	if cookie, err := r.Cookie("ep"); err == nil {
		var value int32
		if err := runtime.BindStyledParameter("simple", true, "ep", cookie.Value, &value); err != nil {
			err = fmt.Errorf("invalid format for parameter ep: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}
		params.Ep = &value

	}

	if cookie, err := r.Cookie("ea"); err == nil {
		var value []int32
		if err := runtime.BindStyledParameter("simple", true, "ea", cookie.Value, &value); err != nil {
			err = fmt.Errorf("invalid format for parameter ea: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}
		params.Ea = &value

	}

	if cookie, err := r.Cookie("a"); err == nil {
		var value []int32
		if err := runtime.BindStyledParameter("simple", false, "a", cookie.Value, &value); err != nil {
			err = fmt.Errorf("invalid format for parameter a: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}
		params.A = &value

	}

	if cookie, err := r.Cookie("eo"); err == nil {
		var value Object
		if err := runtime.BindStyledParameter("simple", true, "eo", cookie.Value, &value); err != nil {
			err = fmt.Errorf("invalid format for parameter eo: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}
		params.Eo = &value

	}

	if cookie, err := r.Cookie("o"); err == nil {
		var value Object
		if err := runtime.BindStyledParameter("simple", false, "o", cookie.Value, &value); err != nil {
			err = fmt.Errorf("invalid format for parameter o: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}
		params.O = &value

	}

	if cookie, err := r.Cookie("co"); err == nil {
		var value ComplexObject
		var decoded string
		decoded, err := url.QueryUnescape(cookie.Value)
		if err != nil {
			err = fmt.Errorf("error unescaping cookie parameter 'co'")
			siw.ErrorHandlerFunc(w, r, &UnescapedCookieParamError{err})
			return
		}

		err = json.Unmarshal([]byte(decoded), &value)
		if err != nil {
			err = fmt.Errorf("error unmarshaling parameter 'co' as JSON: %w", err)
			siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{err})
			return
		}

		params.Co = &value

	}

	if cookie, err := r.Cookie("1s"); err == nil {
		var value string
		if err := runtime.BindStyledParameter("simple", true, "1s", cookie.Value, &value); err != nil {
			err = fmt.Errorf("invalid format for parameter 1s: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}
		params.N1s = &value

	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetCookie(w, r, params)
	})

	handler(w, r.WithContext(ctx))
}

// GetHeader operation middleware
func (siw *ServerInterfaceWrapper) GetHeader(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parameter object where we will unmarshal all parameters from the context
	var params GetHeaderParams

	headers := r.Header

	// ------------- Optional header parameter "X-Primitive" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Primitive")]; found {
		var XPrimitive int32
		n := len(valueList)
		if n != 1 {
			err := fmt.Errorf("expected one value for X-Primitive, got %d", n)
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{err})
			return
		}

		if err := runtime.BindStyledParameterWithLocation("simple", false, "X-Primitive", runtime.ParamLocationHeader, valueList[0], &XPrimitive); err != nil {
			err = fmt.Errorf("invalid format for parameter X-Primitive: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}

		params.XPrimitive = &XPrimitive

	}

	// ------------- Optional header parameter "X-Primitive-Exploded" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Primitive-Exploded")]; found {
		var XPrimitiveExploded int32
		n := len(valueList)
		if n != 1 {
			err := fmt.Errorf("expected one value for X-Primitive-Exploded, got %d", n)
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{err})
			return
		}

		if err := runtime.BindStyledParameterWithLocation("simple", true, "X-Primitive-Exploded", runtime.ParamLocationHeader, valueList[0], &XPrimitiveExploded); err != nil {
			err = fmt.Errorf("invalid format for parameter X-Primitive-Exploded: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}

		params.XPrimitiveExploded = &XPrimitiveExploded

	}

	// ------------- Optional header parameter "X-Array-Exploded" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Array-Exploded")]; found {
		var XArrayExploded []int32
		n := len(valueList)
		if n != 1 {
			err := fmt.Errorf("expected one value for X-Array-Exploded, got %d", n)
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{err})
			return
		}

		if err := runtime.BindStyledParameterWithLocation("simple", true, "X-Array-Exploded", runtime.ParamLocationHeader, valueList[0], &XArrayExploded); err != nil {
			err = fmt.Errorf("invalid format for parameter X-Array-Exploded: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}

		params.XArrayExploded = &XArrayExploded

	}

	// ------------- Optional header parameter "X-Array" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Array")]; found {
		var XArray []int32
		n := len(valueList)
		if n != 1 {
			err := fmt.Errorf("expected one value for X-Array, got %d", n)
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{err})
			return
		}

		if err := runtime.BindStyledParameterWithLocation("simple", false, "X-Array", runtime.ParamLocationHeader, valueList[0], &XArray); err != nil {
			err = fmt.Errorf("invalid format for parameter X-Array: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}

		params.XArray = &XArray

	}

	// ------------- Optional header parameter "X-Object-Exploded" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Object-Exploded")]; found {
		var XObjectExploded Object
		n := len(valueList)
		if n != 1 {
			err := fmt.Errorf("expected one value for X-Object-Exploded, got %d", n)
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{err})
			return
		}

		if err := runtime.BindStyledParameterWithLocation("simple", true, "X-Object-Exploded", runtime.ParamLocationHeader, valueList[0], &XObjectExploded); err != nil {
			err = fmt.Errorf("invalid format for parameter X-Object-Exploded: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}

		params.XObjectExploded = &XObjectExploded

	}

	// ------------- Optional header parameter "X-Object" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Object")]; found {
		var XObject Object
		n := len(valueList)
		if n != 1 {
			err := fmt.Errorf("expected one value for X-Object, got %d", n)
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{err})
			return
		}

		if err := runtime.BindStyledParameterWithLocation("simple", false, "X-Object", runtime.ParamLocationHeader, valueList[0], &XObject); err != nil {
			err = fmt.Errorf("invalid format for parameter X-Object: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}

		params.XObject = &XObject

	}

	// ------------- Optional header parameter "X-Complex-Object" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Complex-Object")]; found {
		var XComplexObject ComplexObject
		n := len(valueList)
		if n != 1 {
			err := fmt.Errorf("expected one value for X-Complex-Object, got %d", n)
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{err})
			return
		}

		if err := json.Unmarshal([]byte(valueList[0]), &XComplexObject); err != nil {
			err = fmt.Errorf("error unmarshaling parameter 'X-Complex-Object' as JSON: %w", err)
			siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{err})
			return
		}

		params.XComplexObject = &XComplexObject

	}

	// ------------- Optional header parameter "1-Starting-With-Number" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("1-Starting-With-Number")]; found {
		var N1StartingWithNumber string
		n := len(valueList)
		if n != 1 {
			err := fmt.Errorf("expected one value for 1-Starting-With-Number, got %d", n)
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{err})
			return
		}

		if err := runtime.BindStyledParameterWithLocation("simple", false, "1-Starting-With-Number", runtime.ParamLocationHeader, valueList[0], &N1StartingWithNumber); err != nil {
			err = fmt.Errorf("invalid format for parameter 1-Starting-With-Number: %w", err)
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
			return
		}

		params.N1StartingWithNumber = &N1StartingWithNumber

	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetHeader(w, r, params)
	})

	handler(w, r.WithContext(ctx))
}

// GetLabelExplodeArray operation middleware
func (siw *ServerInterfaceWrapper) GetLabelExplodeArray(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param []int32

	if err := runtime.BindStyledParameter("label", true, "param", chi.URLParam(r, "param"), &param); err != nil {
		err = fmt.Errorf("invalid format for parameter param: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLabelExplodeArray(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetLabelExplodeObject operation middleware
func (siw *ServerInterfaceWrapper) GetLabelExplodeObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param Object

	if err := runtime.BindStyledParameter("label", true, "param", chi.URLParam(r, "param"), &param); err != nil {
		err = fmt.Errorf("invalid format for parameter param: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLabelExplodeObject(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetLabelNoExplodeArray operation middleware
func (siw *ServerInterfaceWrapper) GetLabelNoExplodeArray(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param []int32

	if err := runtime.BindStyledParameter("label", false, "param", chi.URLParam(r, "param"), &param); err != nil {
		err = fmt.Errorf("invalid format for parameter param: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLabelNoExplodeArray(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetLabelNoExplodeObject operation middleware
func (siw *ServerInterfaceWrapper) GetLabelNoExplodeObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param Object

	if err := runtime.BindStyledParameter("label", false, "param", chi.URLParam(r, "param"), &param); err != nil {
		err = fmt.Errorf("invalid format for parameter param: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetLabelNoExplodeObject(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetMatrixExplodeArray operation middleware
func (siw *ServerInterfaceWrapper) GetMatrixExplodeArray(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "id" -------------
	var id []int32

	if err := runtime.BindStyledParameter("matrix", true, "id", chi.URLParam(r, "id"), &id); err != nil {
		err = fmt.Errorf("invalid format for parameter id: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMatrixExplodeArray(w, r, id)
	})

	handler(w, r.WithContext(ctx))
}

// GetMatrixExplodeObject operation middleware
func (siw *ServerInterfaceWrapper) GetMatrixExplodeObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "id" -------------
	var id Object

	if err := runtime.BindStyledParameter("matrix", true, "id", chi.URLParam(r, "id"), &id); err != nil {
		err = fmt.Errorf("invalid format for parameter id: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMatrixExplodeObject(w, r, id)
	})

	handler(w, r.WithContext(ctx))
}

// GetMatrixNoExplodeArray operation middleware
func (siw *ServerInterfaceWrapper) GetMatrixNoExplodeArray(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "id" -------------
	var id []int32

	if err := runtime.BindStyledParameter("matrix", false, "id", chi.URLParam(r, "id"), &id); err != nil {
		err = fmt.Errorf("invalid format for parameter id: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMatrixNoExplodeArray(w, r, id)
	})

	handler(w, r.WithContext(ctx))
}

// GetMatrixNoExplodeObject operation middleware
func (siw *ServerInterfaceWrapper) GetMatrixNoExplodeObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "id" -------------
	var id Object

	if err := runtime.BindStyledParameter("matrix", false, "id", chi.URLParam(r, "id"), &id); err != nil {
		err = fmt.Errorf("invalid format for parameter id: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMatrixNoExplodeObject(w, r, id)
	})

	handler(w, r.WithContext(ctx))
}

// GetPassThrough operation middleware
func (siw *ServerInterfaceWrapper) GetPassThrough(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param string

	param = chi.URLParam(r, "param")

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPassThrough(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetDeepObject operation middleware
func (siw *ServerInterfaceWrapper) GetDeepObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDeepObjectParams

	// ------------- Required query parameter "deepObj" -------------

	if err := runtime.BindQueryParameter("deepObject", true, true, "deepObj", r.URL.Query(), &params.DeepObj); err != nil {
		err = fmt.Errorf("invalid format for parameter deepObj: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDeepObject(w, r, params)
	})

	handler(w, r.WithContext(ctx))
}

// GetQueryForm operation middleware
func (siw *ServerInterfaceWrapper) GetQueryForm(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// Parameter object where we will unmarshal all parameters from the context
	var params GetQueryFormParams

	// ------------- Optional query parameter "ea" -------------

	if err := runtime.BindQueryParameter("form", true, false, "ea", r.URL.Query(), &params.Ea); err != nil {
		err = fmt.Errorf("invalid format for parameter ea: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	// ------------- Optional query parameter "a" -------------

	if err := runtime.BindQueryParameter("form", false, false, "a", r.URL.Query(), &params.A); err != nil {
		err = fmt.Errorf("invalid format for parameter a: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	// ------------- Optional query parameter "eo" -------------

	if err := runtime.BindQueryParameter("form", true, false, "eo", r.URL.Query(), &params.Eo); err != nil {
		err = fmt.Errorf("invalid format for parameter eo: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	// ------------- Optional query parameter "o" -------------

	if err := runtime.BindQueryParameter("form", false, false, "o", r.URL.Query(), &params.O); err != nil {
		err = fmt.Errorf("invalid format for parameter o: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	// ------------- Optional query parameter "ep" -------------

	if err := runtime.BindQueryParameter("form", true, false, "ep", r.URL.Query(), &params.Ep); err != nil {
		err = fmt.Errorf("invalid format for parameter ep: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	// ------------- Optional query parameter "p" -------------

	if err := runtime.BindQueryParameter("form", false, false, "p", r.URL.Query(), &params.P); err != nil {
		err = fmt.Errorf("invalid format for parameter p: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	// ------------- Optional query parameter "ps" -------------

	if err := runtime.BindQueryParameter("form", true, false, "ps", r.URL.Query(), &params.Ps); err != nil {
		err = fmt.Errorf("invalid format for parameter ps: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	// ------------- Optional query parameter "co" -------------

	if paramValue := r.URL.Query().Get("co"); paramValue != "" {

		var value ComplexObject
		if err := json.Unmarshal([]byte(paramValue), &value); err != nil {
			err = fmt.Errorf("error unmarshaling parameter 'co' as JSON: %w", err)
			siw.ErrorHandlerFunc(w, r, &UnmarshalingParamError{err})
			return
		}
		params.Co = &value

	}

	// ------------- Optional query parameter "1s" -------------

	if err := runtime.BindQueryParameter("form", true, false, "1s", r.URL.Query(), &params.N1s); err != nil {
		err = fmt.Errorf("invalid format for parameter 1s: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetQueryForm(w, r, params)
	})

	handler(w, r.WithContext(ctx))
}

// GetSimpleExplodeArray operation middleware
func (siw *ServerInterfaceWrapper) GetSimpleExplodeArray(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param []int32

	if err := runtime.BindStyledParameter("simple", true, "param", chi.URLParam(r, "param"), &param); err != nil {
		err = fmt.Errorf("invalid format for parameter param: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSimpleExplodeArray(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetSimpleExplodeObject operation middleware
func (siw *ServerInterfaceWrapper) GetSimpleExplodeObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param Object

	if err := runtime.BindStyledParameter("simple", true, "param", chi.URLParam(r, "param"), &param); err != nil {
		err = fmt.Errorf("invalid format for parameter param: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSimpleExplodeObject(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetSimpleNoExplodeArray operation middleware
func (siw *ServerInterfaceWrapper) GetSimpleNoExplodeArray(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param []int32

	if err := runtime.BindStyledParameter("simple", false, "param", chi.URLParam(r, "param"), &param); err != nil {
		err = fmt.Errorf("invalid format for parameter param: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSimpleNoExplodeArray(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetSimpleNoExplodeObject operation middleware
func (siw *ServerInterfaceWrapper) GetSimpleNoExplodeObject(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param Object

	if err := runtime.BindStyledParameter("simple", false, "param", chi.URLParam(r, "param"), &param); err != nil {
		err = fmt.Errorf("invalid format for parameter param: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSimpleNoExplodeObject(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetSimplePrimitive operation middleware
func (siw *ServerInterfaceWrapper) GetSimplePrimitive(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "param" -------------
	var param int32

	if err := runtime.BindStyledParameter("simple", false, "param", chi.URLParam(r, "param"), &param); err != nil {
		err = fmt.Errorf("invalid format for parameter param: %w", err)
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{err})
		return
	}

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSimplePrimitive(w, r, param)
	})

	handler(w, r.WithContext(ctx))
}

// GetStartingWithNumber operation middleware
func (siw *ServerInterfaceWrapper) GetStartingWithNumber(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	// ------------- Path parameter "1param" -------------
	var n1param string

	n1param = chi.URLParam(r, "1param")

	var handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetStartingWithNumber(w, r, n1param)
	})

	handler(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	error
}
type UnmarshalingParamError struct {
	error
}
type RequiredParamError struct {
	error
}
type RequiredHeaderError struct {
	error
}
type InvalidParamFormatError struct {
	error
}
type TooManyValuesForParamError struct {
	error
}

type ServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      map[string]func(http.Handler) http.Handler
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

type ServerOption func(*ServerOptions)

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface, opts ...ServerOption) http.Handler {
	options := &ServerOptions{
		BaseURL:     "/",
		BaseRouter:  chi.NewRouter(),
		Middlewares: make(map[string]func(http.Handler) http.Handler),
		ErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
	}

	for _, f := range opts {
		f(options)
	}

	r := options.BaseRouter
	wrapper := ServerInterfaceWrapper{
		Handler:          si,
		Middlewares:      options.Middlewares,
		ErrorHandlerFunc: options.ErrorHandlerFunc,
	}

	r.Route(options.BaseURL, func(r chi.Router) {
		r.Get("/contentObject/{param}", wrapper.GetContentObject)
		r.Get("/cookie", wrapper.GetCookie)
		r.Get("/header", wrapper.GetHeader)
		r.Get("/labelExplodeArray/{param}", wrapper.GetLabelExplodeArray)
		r.Get("/labelExplodeObject/{param}", wrapper.GetLabelExplodeObject)
		r.Get("/labelNoExplodeArray/{param}", wrapper.GetLabelNoExplodeArray)
		r.Get("/labelNoExplodeObject/{param}", wrapper.GetLabelNoExplodeObject)
		r.Get("/matrixExplodeArray/{id}", wrapper.GetMatrixExplodeArray)
		r.Get("/matrixExplodeObject/{id}", wrapper.GetMatrixExplodeObject)
		r.Get("/matrixNoExplodeArray/{id}", wrapper.GetMatrixNoExplodeArray)
		r.Get("/matrixNoExplodeObject/{id}", wrapper.GetMatrixNoExplodeObject)
		r.Get("/passThrough/{param}", wrapper.GetPassThrough)
		r.Get("/queryDeepObject", wrapper.GetDeepObject)
		r.Get("/queryForm", wrapper.GetQueryForm)
		r.Get("/simpleExplodeArray/{param}", wrapper.GetSimpleExplodeArray)
		r.Get("/simpleExplodeObject/{param}", wrapper.GetSimpleExplodeObject)
		r.Get("/simpleNoExplodeArray/{param}", wrapper.GetSimpleNoExplodeArray)
		r.Get("/simpleNoExplodeObject/{param}", wrapper.GetSimpleNoExplodeObject)
		r.Get("/simplePrimitive/{param}", wrapper.GetSimplePrimitive)
		r.Get("/startingWithNumber/{1param}", wrapper.GetStartingWithNumber)

	})
	return r
}

func WithRouter(r chi.Router) ServerOption {
	return func(s *ServerOptions) {
		s.BaseRouter = r
	}
}

func WithServerBaseURL(url string) ServerOption {
	return func(s *ServerOptions) {
		s.BaseURL = url
	}
}

func WithMiddleware(key string, middleware func(http.Handler) http.Handler) ServerOption {
	return func(s *ServerOptions) {
		s.Middlewares[key] = middleware
	}
}

func WithMiddlewares(middlewares map[string]func(http.Handler) http.Handler) ServerOption {
	return func(s *ServerOptions) {
		s.Middlewares = middlewares
	}
}

func WithErrorHandler(handler func(w http.ResponseWriter, r *http.Request, err error)) ServerOption {
	return func(s *ServerOptions) {
		s.ErrorHandlerFunc = handler
	}
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/9xaS4/bNhD+K8a0p0K27OSmW5C+Fmg2ab1ACgR74Epji6kkMiS99cLQfy9IypZEybL8",
	"0NrpLSvN45uPw8/kKBsIWcpZhpmSEGxAoOQsk2j+mNOUJ/hX8Ug/CVmmMFP6nwrXyucJoZn+S4YxpsQ8",
	"f+EIAUglaLaEPM89iFCGgnJFWQYBvBtJE3e0zTViT18xVKBNbRyT/T3TVuuP9mWwAS4YR6GoBXcXVbLR",
	"TOESBeQe3Ml3UWpBFS+fGEuQZPplGexHgQsI4Ae/rN8vkvsfSzwCv62owAiCL1tnT6cu8zzWwtYxLqiQ",
	"6p6k2EKMB4IlbS+crMbKq4R6NJzSbMG0c0JDLBYnM4ngw92Djq6o0uHhAaUazVE8owAPnlFIuwyzyXQy",
	"1YaMY0Y4hQDeTqaTGXjAiYoNfr9Yb1ufv+FEkDTXb5ZoytXFEr2uejXgN1Tvqw4mlCApKhQSgi+1/iGc",
	"JzQ0zv5XyZwu6lqeemMUbEBgYIO3pcFkhiqXSqwwf/TqPf5mOt2Xb2fnOxshNzn9kLF/KHazYSwaNNQ3",
	"BBc0pYo+a0Nc84RFCMGCJBKLwsJtmG1pjbK8CnULJlKi7KZ4+wa8xh7JvV4IbNxWAHhxBEXWaESEIC99",
	"YRCopqUKU9kr/+6JzdaCpwGjaz2Gg7GjhW03VC9eWOfy9JM+F0oTQRcll0EwlFzUKwutQclxa0Vhs6Qm",
	"Sdp2JBURimbL0b9UxaNslT4Z6W2NOpOdRLk/DXX1ylZJYpQoRhKh6FKi363FuUoUb8MU8P8ef6q4vKom",
	"dUAZ/1Jsm6uoVBPYO21dBXUFzdqD6srK1URlt2m/FRxCyPYh+u71rFlYEWhfgSeom5tjNp4X1uPPVMXj",
	"+6312YqXkCdMiiYxjexvJkbafuo8nv7hujUVsa1N+5wsL7ORPJDqxZzbTYVwyfNqlbPtif5Y0vYd7C/B",
	"Wp9dNDg/96ytqw7zU/frIKgqNv+jvtrVX++sI4g72FrnMHft3kqJEnTttBaNujfeh4bTKRuPRoP3lK1u",
	"OMJ2PXUUY6drFY0u2EyDkdOQKhr1IOcCQvU9d1RTp45j7QyVuvWu4kTKh1iw1TLuM+r7VJp3DvqOGBRf",
	"ZYz3bYXi5WdEXk5x95VcsTpwk44QeffVx6Qt64xs6JM7xLkVlI0SlZj3HaYNlF+ZSLtq/3NndKD0Xpdk",
	"p/qLTfLKurUrHHlJdlC9Gqh+l2WXs9ef8jkIhgCwo+LQ/Mdl43WG4h1sDAdgVGjknrzHjRCvPIZwwF9m",
	"quoEPWuoetZvif2yWT+W9bhhzxtutzuXsCXCYKzVvjUeQdvtTCYGY8g98B8+o81b/G54NjE8c/2/ZM/b",
	"HG9iOjEYS7sPKP35qX7+cZg5iYkezTMkDcVvzGeqYjur9jezHlQ03Aa8EM0GvhFphs3/FrG4VyKBAGKl",
	"eOD7uCbafhKyFPLH/L8AAAD//8E4OSo9JAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
